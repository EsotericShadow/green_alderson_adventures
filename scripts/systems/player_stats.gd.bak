extends Node
## Global player stats system (autoload singleton).
## Manages health, mana, and stamina only.
## Other functionality has been split into dedicated systems:
## - XP/Leveling: XPLevelingSystem
## - Gold: CurrencySystem
## - Regeneration: ResourceRegenSystem
## - Damage reduction: CombatSystem
## - Movement multipliers: MovementSystem
## - Carry weight: InventorySystem

# Logging
var _logger = GameLogger.create("[PlayerStats] ")

# Signals (LOCKED NAMES per SPEC.md)
signal health_changed(current: int, maximum: int)
signal mana_changed(current: int, maximum: int)
signal stamina_changed(current: int, maximum: int)
signal player_died

# Current Values (LOCKED NAMES per SPEC.md)
var _health: int = 100
var _mana: int = 75
var _stamina: int = 50

# Constants (now loaded from GameBalance config)
# These are kept as fallback defaults but should use GameBalance getters
const HEALTH_PER_VIT: int = 20  # Use GameBalance.get_health_per_vit() instead
const MANA_PER_INT: int = 15  # Use GameBalance.get_mana_per_int() instead
const STAMINA_PER_AGILITY: int = 10  # Use GameBalance.get_stamina_per_agility() instead




func _ready() -> void:
	_logger.log_info("PlayerStats initialized")
	# Initialize health/mana/stamina to max values
	_health = get_max_health()
	_mana = get_max_mana()
	_stamina = get_max_stamina()
	_logger.log_info("Initialized: Health=" + str(_health) + ", Mana=" + str(_mana) + ", Stamina=" + str(_stamina))


# Derived Stats (delegates to XPLevelingSystem and InventorySystem)
func get_total_resilience() -> int:
	if XPLevelingSystem != null and InventorySystem != null:
		var base_stat: int = XPLevelingSystem.get_base_stat_level(StatConstants.STAT_RESILIENCE)
		var equipment: Dictionary = InventorySystem.get_all_equipped()
		var bonus: int = EquipmentStatCalculator.get_total_stat_bonus(equipment, StatConstants.STAT_RESILIENCE)
		return base_stat + bonus
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_level(StatConstants.STAT_RESILIENCE)
	return 1  # Fallback


func get_total_agility() -> int:
	if XPLevelingSystem != null and InventorySystem != null:
		var base_stat: int = XPLevelingSystem.get_base_stat_level(StatConstants.STAT_AGILITY)
		var equipment: Dictionary = InventorySystem.get_all_equipped()
		var bonus: int = EquipmentStatCalculator.get_total_stat_bonus(equipment, StatConstants.STAT_AGILITY)
		return base_stat + bonus
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_level(StatConstants.STAT_AGILITY)
	return 1  # Fallback


func get_total_int() -> int:
	if XPLevelingSystem != null and InventorySystem != null:
		var base_stat: int = XPLevelingSystem.get_base_stat_level(StatConstants.STAT_INT)
		var equipment: Dictionary = InventorySystem.get_all_equipped()
		var bonus: int = EquipmentStatCalculator.get_total_stat_bonus(equipment, StatConstants.STAT_INT)
		return base_stat + bonus
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_level(StatConstants.STAT_INT)
	return 1  # Fallback


func get_total_vit() -> int:
	if XPLevelingSystem != null and InventorySystem != null:
		var base_stat: int = XPLevelingSystem.get_base_stat_level(StatConstants.STAT_VIT)
		var equipment: Dictionary = InventorySystem.get_all_equipped()
		var bonus: int = EquipmentStatCalculator.get_total_stat_bonus(equipment, StatConstants.STAT_VIT)
		return base_stat + bonus
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_level(StatConstants.STAT_VIT)
	return 1  # Fallback


func get_max_health() -> int:
	var health_per_vit: int = GameBalance.get_health_per_vit()
	return get_total_vit() * health_per_vit


func get_max_mana() -> int:
	var mana_per_int: int = GameBalance.get_mana_per_int()
	return get_total_int() * mana_per_int


func get_max_stamina() -> int:
	var stamina_per_agility: int = GameBalance.get_stamina_per_agility()
	return get_total_agility() * stamina_per_agility


# Carry weight methods moved to InventorySystem


# Health Methods (LOCKED SIGNATURES per SPEC.md)
func get_health() -> int:
	return _health


func set_health(value: int) -> void:
	var old_health: int = _health
	_health = clampi(value, 0, get_max_health())
	if _health != old_health:
		_logger.log("Health changed: " + str(old_health) + " â†’ " + str(_health) + "/" + str(get_max_health()))
		health_changed.emit(_health, get_max_health())
		if _health <= 0:
			_logger.log("Player died!")
			player_died.emit()


func heal(amount: int) -> void:
	set_health(_health + amount)


func take_damage(amount: int) -> void:
	# Apply resilience-based damage reduction via CombatSystem
	var resilience: int = get_total_resilience()
	var reduced_damage: int = CombatSystem.calculate_damage_reduction(amount, resilience)
	_logger.log("Taking damage: " + str(amount) + " â†’ " + str(reduced_damage) + " (reduced by resilience)")
	set_health(_health - reduced_damage)
	# Gain Resilience XP for taking damage
	if reduced_damage > 0 and XPLevelingSystem != null:
		XPLevelingSystem.gain_resilience_xp_for_damage_dealt(reduced_damage)


# Mana Methods (LOCKED SIGNATURES per SPEC.md)
func get_mana() -> int:
	return _mana


func set_mana(value: int) -> void:
	var old_mana: int = _mana
	_mana = clampi(value, 0, get_max_mana())
	if _mana != old_mana:
		_logger.log("Mana changed: " + str(old_mana) + " â†’ " + str(_mana) + "/" + str(get_max_mana()))
		mana_changed.emit(_mana, get_max_mana())


func consume_mana(amount: int) -> bool:
	if not has_mana(amount):
		_logger.log("Failed to consume " + str(amount) + " mana (insufficient)")
		return false
	_logger.log("Consuming " + str(amount) + " mana")
	set_mana(_mana - amount)
	# Gain Intelligence XP for casting spells (whether they hit or not)
	if amount > 0 and XPLevelingSystem != null:
		XPLevelingSystem.gain_base_stat_xp(StatConstants.STAT_INT, max(1, int(amount / 2.5)), StatConstants.STAT_INT)
	return true


func has_mana(amount: int) -> bool:
	return _mana >= amount


func restore_mana(amount: int) -> void:
	set_mana(_mana + amount)


# Stamina Methods (LOCKED SIGNATURES per SPEC.md)
func get_stamina() -> int:
	return _stamina


func set_stamina(value: int) -> void:
	var old_stamina: int = _stamina
	_stamina = clampi(value, 0, get_max_stamina())
	if _stamina != old_stamina:
		_logger.log("Stamina changed: " + str(old_stamina) + " â†’ " + str(_stamina) + "/" + str(get_max_stamina()))
		stamina_changed.emit(_stamina, get_max_stamina())


func consume_stamina(amount: int) -> bool:
	if amount <= 0:
		return true  # Nothing to consume
	
	# Apply agility-based consumption reduction via MovementSystem
	var agility: int = get_total_agility()
	var multiplier: float = MovementSystem.get_stamina_consumption_multiplier(agility)
	var adjusted_amount: float = float(amount) * multiplier
	# Round to nearest int to avoid truncating to 0, but ensure at least 1 if original amount > 0
	var final_amount: int = max(1, int(round(adjusted_amount)))
	
	if not has_stamina(final_amount):
		_logger.log("Failed to consume " + str(final_amount) + " stamina (insufficient)")
		return false
	_logger.log("Consuming " + str(final_amount) + " stamina (multiplier: " + str(multiplier) + ", original: " + str(amount) + ")")
	set_stamina(_stamina - final_amount)
	# Gain Agility XP for using stamina
	if final_amount > 0 and XPLevelingSystem != null:
		XPLevelingSystem.gain_base_stat_xp(StatConstants.STAT_AGILITY, max(1, int(final_amount / 3.5)), StatConstants.STAT_AGILITY)
	return true


func has_stamina(amount: int) -> bool:
	return _stamina >= amount


func restore_stamina(amount: int) -> void:
	set_stamina(_stamina + amount)


# Gold methods moved to CurrencySystem
# Base stat XP and leveling methods moved to XPLevelingSystem
# Delegation methods for backwards compatibility:

func get_base_stat_level(stat_name: String) -> int:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_level(stat_name)
	return 1  # Fallback


func get_base_stat_xp(stat_name: String) -> int:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_xp(stat_name)
	return 0  # Fallback


func get_stat_display_data(stat_name: String) -> Dictionary:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_stat_display_data(stat_name)
	return {"level": 1, "total_xp": 0, "xp_in_level": 0, "xp_needed": 1, "xp_for_current": 0, "xp_for_next": 100}


func get_character_level() -> int:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_character_level()
	return 1  # Fallback


func get_character_level_info() -> Dictionary:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_character_level_info()
	return {"character_level": 1, "total_skill_levels": 0, "levels_needed_for_next": 8}


func get_carry_weight_slow_multiplier() -> float:
	"""Delegates to InventorySystem."""
	if InventorySystem != null:
		return InventorySystem.get_carry_weight_slow_multiplier()
	return 1.0  # Fallback


func get_base_stat_xp_for_current_level(stat_name: String) -> int:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_xp_for_current_level(stat_name)
	return 0  # Fallback


func get_base_stat_xp_for_next_level(stat_name: String) -> int:
	"""Delegates to XPLevelingSystem."""
	if XPLevelingSystem != null:
		return XPLevelingSystem.get_base_stat_xp_for_next_level(stat_name)
	return 100  # Fallback


	"""Returns current XP for a base stat.
	
	Args:
		stat_name: The stat name (use StatConstants.STAT_*)
		
	Returns:
		Current total XP for the stat, or 0 if stat doesn't exist
	"""
	if not base_stat_xp.has(stat_name):
		_logger.log_error("get_base_stat_xp() called with unknown stat: " + stat_name)
		return 0
	return base_stat_xp[stat_name]


func get_base_stat_xp_for_current_level(stat_name: String) -> int:
	"""Returns the minimum total XP needed for the current level (using RuneScape XP formula).
	
	Args:
		stat_name: The stat name (use StatConstants.STAT_*)
		
	Returns:
		Total XP required for current level, or 0 if stat doesn't exist
	"""
	if not base_stat_xp.has(stat_name):
		_logger.log_error("get_base_stat_xp_for_current_level() called with unknown stat: " + stat_name)
		return 0
	var current_level: int = get_base_stat_level(stat_name)
	return XPFormula.get_xp_for_current_level(current_level) if XPFormula != null else 0


func get_base_stat_xp_for_next_level(stat_name: String) -> int:
	"""Returns the total XP needed to reach the next level for a base stat (using RuneScape XP formula).
	
	Args:
		stat_name: The stat name (use StatConstants.STAT_*)
		
	Returns:
		Total XP required for next level, or 100 if stat doesn't exist (fallback)
	"""
	if not base_stat_xp.has(stat_name):
		_logger.log_error("get_base_stat_xp_for_next_level() called with unknown stat: " + stat_name)
		return 100  # Fallback default
	var current_level: int = get_base_stat_level(stat_name)
	return XPFormula.get_xp_for_next_level(current_level) if XPFormula != null else 100


## Returns display data for a base stat (single source of truth for UI)
## Uses stored level from PlayerStats, not calculated from XP
## Returns Dictionary with: level, total_xp, xp_in_level, xp_needed, xp_for_current, xp_for_next
func get_stat_display_data(stat_name: String) -> Dictionary:
	"""Returns all display data needed for UI in a single call.
	
	This method encapsulates all XP/level calculation logic, removing it from the UI layer.
	Uses stored level as the source of truth (not recalculated from XP).
	
	Args:
		stat_name: The stat name (use StatConstants.STAT_*)
		
	Returns:
		Dictionary containing:
			- level: int - Current level
			- total_xp: int - Total XP accumulated
			- xp_in_level: int - XP gained within current level (for progress bar)
			- xp_needed: int - XP needed to complete current level
			- xp_for_current: int - Total XP required for current level
			- xp_for_next: int - Total XP required for next level
	"""
	if not base_stat_xp.has(stat_name):
		_logger.log_error("get_stat_display_data() called with unknown stat: " + stat_name)
		return {
			"level": 1,
			"total_xp": 0,
			"xp_in_level": 0,
			"xp_needed": 1,
			"xp_for_current": 0,
			"xp_for_next": 100
		}
	
	var total_xp: int = base_stat_xp[stat_name]
	var level: int = get_base_stat_level(stat_name)  # Stored level (source of truth)
	var xp_for_current: int = XPFormula.get_xp_for_level(level) if XPFormula != null else 0
	var xp_for_next: int = XPFormula.get_xp_for_level(level + 1) if XPFormula != null else 100
	var xp_in_level: int = max(0, total_xp - xp_for_current)  # Clamp to 0 to prevent negatives
	var xp_needed: int = max(1, xp_for_next - xp_for_current)  # Ensure at least 1 to prevent division by zero
	
	return {
		"level": level,
		"total_xp": total_xp,
		"xp_in_level": xp_in_level,
		"xp_needed": xp_needed,
		"xp_for_current": xp_for_current,
		"xp_for_next": xp_for_next
	}


func _check_base_stat_level_up(stat_name: String) -> void:
	"""Checks if a base stat should level up and handles it."""
	if not base_stat_xp.has(stat_name):
		return
	
	var current_level: int = get_base_stat_level(stat_name)
	var max_level: int = GameBalance.get_max_base_stat_level()
	
	# Check if already at max level
	if current_level >= max_level:
		_logger.log_info(stat_name.capitalize() + " at max level (" + str(max_level) + "), cannot level up")
		return  # Can't level up past max
	
	var current_xp: int = base_stat_xp[stat_name]
	
	# Calculate what level this XP should correspond to (using RuneScape formula)
	var calculated_level: int = XPFormula.get_level_from_xp(current_xp)
	
	# Cap calculated level to max
	if calculated_level > max_level:
		calculated_level = max_level
	
	# Check if we should level up
	if calculated_level > current_level:
		# Level up to the calculated level (could be multiple levels)
		var old_level: int = current_level
		
		# Set stat to calculated level (handling multiple level-ups)
		var level_diff: int = calculated_level - current_level
		for i in range(level_diff):
			_increment_base_stat(stat_name)
		
		var new_level: int = get_base_stat_level(stat_name)
		var xp_for_new_level: int = XPFormula.get_xp_for_level(new_level)
		
		_logger.log_info("ðŸŽ‰ " + stat_name.capitalize() + " LEVELED UP! Level " + str(old_level) + " â†’ " + str(new_level) + " (XP: " + str(current_xp) + ", needed: " + str(xp_for_new_level) + ")")
		
		# Emit signal for UI updates and game events
		base_stat_leveled_up.emit(stat_name, new_level)
		stat_changed.emit(stat_name, new_level)
		
		# Update health/mana/stamina if relevant stat leveled up
		_update_resource_caps(stat_name)


func _increment_base_stat(stat_name: String) -> void:
	"""Increments a base stat by 1 level (uses proper setter)."""
	var current_level: int = get_base_stat_level(stat_name)
	var new_level: int = current_level + 1
	set_base_stat_level(stat_name, new_level)


func _update_resource_caps(stat_name: String) -> void:
	"""Updates health/mana/stamina caps when relevant stat levels up."""
	match stat_name:
		StatConstants.STAT_VIT:
			var new_max: int = get_max_health()
			if health > new_max:
				set_health(new_max)
		StatConstants.STAT_INT:
			var new_max: int = get_max_mana()
			if mana > new_max:
				set_mana(new_max)
		StatConstants.STAT_AGILITY:
			var new_max: int = get_max_stamina()
			if stamina > new_max:
				set_stamina(new_max)


func get_base_stat_level(stat_name: String) -> int:
	"""Returns the stored level for a base stat (simple getter, source of truth for display)."""
	match stat_name:
		StatConstants.STAT_RESILIENCE, "str":  # Backward compatibility
			return base_resilience
		StatConstants.STAT_AGILITY, "dex":  # Backward compatibility
			return base_agility
		StatConstants.STAT_INT:
			return base_int
		StatConstants.STAT_VIT:
			return base_vit
	return 1


func get_carry_weight_slow_multiplier() -> float:
	"""Returns movement speed multiplier when carrying heavy load (85%+ weight)."""
	var current_weight: float = get_current_carry_weight()
	var max_weight: float = get_max_carry_weight()
	return StatFormulas.calculate_carry_weight_slow_multiplier(current_weight, max_weight)


# Character Level Methods (combines all base stats + magic elements)
func get_character_level() -> int:
	"""Returns the player's character level based on all stats (base stats + magic elements)."""
	if SpellSystem == null:
		return 1  # Default if SpellSystem not available
	
	var fire_level: int = SpellSystem.get_level("fire")
	var water_level: int = SpellSystem.get_level("water")
	var earth_level: int = SpellSystem.get_level("earth")
	var air_level: int = SpellSystem.get_level("air")
	
	return CharacterLevel.get_character_level(
		get_total_resilience(),
		get_total_agility(),
		get_total_int(),
		get_total_vit(),
		fire_level,
		water_level,
		earth_level,
		air_level
	)


func get_character_level_info() -> Dictionary:
	"""Returns full character level information including total skill levels."""
	if SpellSystem == null:
		return {"character_level": 1, "total_skill_levels": 0, "levels_needed_for_next": 8}
	
	var fire_level: int = SpellSystem.get_level("fire")
	var water_level: int = SpellSystem.get_level("water")
	var earth_level: int = SpellSystem.get_level("earth")
	var air_level: int = SpellSystem.get_level("air")
	
	return CharacterLevel.calculate_character_level(
		get_total_resilience(),
		get_total_agility(),
		get_total_int(),
		get_total_vit(),
		fire_level,
		water_level,
		earth_level,
		air_level
	)


func _update_character_level() -> void:
	"""Recalculates and emits character level changed signal."""
	var new_level: int = get_character_level()
	character_level_changed.emit(new_level)


# Method to gain Resilience XP when dealing damage (called from combat system)
func gain_resilience_xp_for_damage_dealt(damage: int) -> void:
	"""Called when player deals damage to gain Resilience XP."""
	if damage > 0:
		gain_base_stat_xp(StatConstants.STAT_RESILIENCE, max(1, int(damage / 2.0)), StatConstants.STAT_RESILIENCE)


# Stat Modification Methods (UPDATED: Resilience/Agility)
func set_base_stat(stat_name: String, value: int) -> void:
	var old_value: int = 0
	match stat_name:
		StatConstants.STAT_RESILIENCE, "str":  # Support both for backwards compatibility
			old_value = base_resilience
			base_resilience = value
			_logger.log("Resilience changed: " + str(old_value) + " â†’ " + str(value))
			stat_changed.emit(StatConstants.STAT_RESILIENCE, value)
			_update_character_level()
		StatConstants.STAT_AGILITY, "dex":  # Support both for backwards compatibility
			old_value = base_agility
			base_agility = value
			_logger.log("Agility changed: " + str(old_value) + " â†’ " + str(value))
			stat_changed.emit(StatConstants.STAT_AGILITY, value)
			_update_character_level()
		StatConstants.STAT_INT:
			old_value = base_int
			base_int = value
			_logger.log("Intelligence changed: " + str(old_value) + " â†’ " + str(value))
			stat_changed.emit(StatConstants.STAT_INT, value)
			_update_character_level()
		StatConstants.STAT_VIT:
			old_value = base_vit
			base_vit = value
			_logger.log("Vitality changed: " + str(old_value) + " â†’ " + str(value))
			stat_changed.emit(StatConstants.STAT_VIT, value)
			# Update health if VIT changed
			var new_max: int = get_max_health()
			if health > new_max:
				set_health(new_max)
			_update_character_level()


func set_base_stat_level(stat_name: String, level: int) -> void:
	"""Sets a base stat to a specific level.
	
	This method provides proper encapsulation for leveling systems to update player stats.
	Validates input and emits appropriate signals.
	
	Args:
		stat_name: The stat to modify (use StatConstants.STAT_*)
		level: The new level value
	"""
	set_base_stat(stat_name, level)


func recalculate_stat_levels_from_xp() -> void:
	"""Recalculates all base stat levels from their current XP values.
	
	This is useful when loading game state or syncing from external sources.
	Each stat's level will be recalculated based on its current XP using the XP formula.
	"""
	_check_base_stat_level_up(StatConstants.STAT_RESILIENCE)
	_check_base_stat_level_up(StatConstants.STAT_AGILITY)
	_check_base_stat_level_up(StatConstants.STAT_INT)
	_check_base_stat_level_up(StatConstants.STAT_VIT)
